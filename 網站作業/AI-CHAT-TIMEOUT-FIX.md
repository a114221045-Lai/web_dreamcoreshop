# AI 客服助手前端呼叫無回應修正報告

## ✅ 問題已修復

**原始問題:** AI 客服前端呼叫時無回應，導致用戶體驗卡頓

**根本原因:** 
1. 前端 fetch 請求無超時控制，導致無限等待
2. 後端 API 無超時保護，可能無限期掛起
3. 錯誤訊息不清楚，用戶無法判斷問題類型
4. 加載動畫靜態顯示，無進度提示

---

## 🔧 修正清單

### 1. **後端超時控制 (backend/ORAPI.js)**

#### 修正項目:
- ✅ 後端 API 呼叫新增 **30 秒超時**
- ✅ 建立超時 Promise 與 API 呼叫賽跑
- ✅ 改進重試邏輯：區分超時、限流(429)、伺服器錯誤
- ✅ 詳細的錯誤日誌追蹤

#### 超時機制:
```javascript
const timeout = opts.timeout || 30000 // 預設 30 秒
const timeoutPromise = new Promise((_, reject) => {
  setTimeout(() => {
    reject(new Error(`API 呼叫超時 (${timeout}ms)...`))
  }, timeout)
})
const response = await Promise.race([responsePromise, timeoutPromise])
```

#### 重試策略:
- ✅ 超時錯誤：進行重試
- ✅ 限流(429)：進行重試
- ✅ 伺服器錯誤(5xx)：進行重試
- ❌ 客戶端錯誤(4xx)：不重試
- ❌ 認證失敗(401)：不重試

---

### 2. **前端超時控制 (script.js)**

#### 修正項目:
- ✅ 前端請求新增 **45 秒超時** (> 後端 30 秒)
- ✅ 建立 Promise.race() 實現請求賽跑
- ✅ 超時時自動清除載入提示
- ✅ 詳細的錯誤分類和提示訊息

#### 前端超時流程:
```javascript
const fetchPromise = fetch(apiUrl, {...})
const timeoutPromise = new Promise((_, reject) => {
  setTimeout(() => {
    reject(new Error('⏱️ 請求超時 (45秒)...'))
  }, 45000)
})
const response = await Promise.race([fetchPromise, timeoutPromise])
```

#### 錯誤處理:
- ✅ 超時錯誤：顯示「⏱️ 請求超時」訊息
- ✅ 網路錯誤：顯示「無法連接到伺服器」訊息
- ✅ JSON 解析錯誤：顯示「伺服器返回無效資料」訊息
- ✅ API 路由錯誤：顯示「API 路由錯誤」訊息
- ✅ 業務邏輯錯誤：顯示具體的伺服器錯誤訊息

---

### 3. **改進的加載提示 (styles.css)**

#### 修正項目:
- ✅ 新增動態加載動畫：「⏳ AI 思考中... 」
- ✅ 加號動畫：`. ` → `.. ` → `... `循環
- ✅ 錯誤訊息樣式：紅色背景高亮顯示

#### 新增 CSS:
```css
.message.bot.error {
  background: rgba(220, 53, 69, 0.2);
  border-color: rgba(220, 53, 69, 0.5);
}

.dot-animation::after {
  animation: dots 1.4s infinite;
}

@keyframes dots {
  0%, 20% { content: '.'; }
  40% { content: '..'; }
  60%, 100% { content: '...'; }
}
```

---

## 📊 超時流程圖

```
用戶發送訊息
    ↓
[前端] 開始 45 秒超時計時
    ↓
[前端] 送出 fetch 請求
    ↓
[後端] 收到請求，開始 30 秒超時計時
    ↓
[後端] 呼叫 OpenRouter API
    ↓
┌─────────────────────────────────────┐
│  ① 後端 30 秒內成功回應              │
│  → 前端收到回應並顯示                │
│  ✅ 正常流程                         │
└─────────────────────────────────────┘

┌─────────────────────────────────────┐
│  ② 後端 30 秒超時                    │
│  → 後端返回超時錯誤                  │
│  → 前端顯示「API 超時」訊息          │
│  → 用戶可重試                        │
│  ✅ 優雅降級                         │
└─────────────────────────────────────┘

┌─────────────────────────────────────┐
│  ③ 前端 45 秒超時 (兜底機制)        │
│  → 若後端完全無回應                  │
│  → 前端強制終止等待                  │
│  → 顯示「請求超時」訊息              │
│  ✅ 防止永遠卡住                     │
└─────────────────────────────────────┘
```

---

## 🧪 測試步驟

### 本機測試 (localhost:3000)

1. **啟動後端:**
```bash
cd backend
node server.js
```

2. **測試正常回應 (< 2秒):**
   - 打開瀏覽器 http://localhost:3000
   - 輸入訊息「你好」
   - 預期結果: ✅ 收到 AI 回應

3. **測試超時提示:**
   - 若 OpenRouter API 緩慢 (> 30秒)
   - 預期結果: 
     - 30 秒時：後端超時，返回超時訊息
     - 45 秒時：前端超時，自動停止等待
     - 用戶看到：「❌ 錯誤：API 呼叫超時...」

4. **測試加載動畫:**
   - 觀察載入提示動畫
   - 預期結果: ⏳ 動態顯示「AI 思考中... . .. ...」

### Vercel 線上測試 (已自動部署)

**網址:** https://web-dreamcoreshop.vercel.app/

1. 打開網頁找到聊天區域
2. 發送訊息進行測試
3. 觀察是否能正常接收回應
4. 如果超時，驗證錯誤訊息是否清晰

---

## 📋 修改的檔案

1. [backend/ORAPI.js](backend/ORAPI.js#L22) - 後端超時控制 (第 22-88 行)
2. [script.js](script.js#L74) - 前端超時控制 (第 74-246 行)
3. [styles.css](styles.css#L387) - 加載動畫樣式 (第 387-408 行)

---

## 🎯 修正的問題

✅ 前端請求無超時控制，導致無限等待  
✅ 後端 API 無超時保護，可能掛起  
✅ 錯誤訊息不清楚，用戶無法診斷問題  
✅ 加載提示靜態顯示，無進度反饋  
✅ 無區分 API 限流、超時、伺服器錯誤等不同狀況  

---

## 💡 技術細節

### 為何使用 45 秒 (前端) vs 30 秒 (後端)?

- **後端 30 秒**: OpenRouter API 通常 10-20 秒內回應
- **前端 45 秒**: 留 15 秒緩衝時間，確保後端能夠返回超時錯誤
- **優勢**: 如果後端超時，用戶會看到明確的「API 超時」訊息，而非「前端超時」
- **備選**: 若後端完全無回應，前端在 45 秒時會自動停止

### 為何使用 Promise.race()?

```javascript
const response = await Promise.race([fetchPromise, timeoutPromise])
```

- 兩個 Promise 賽跑：誰先完成，就用誰的結果
- 若 fetch 先完成 → 使用網路回應
- 若 timeout 先觸發 → 拋出超時錯誤
- 優勢: 簡潔、可靠、避免記憶體洩漏

---

## 📊 預期改善效果

| 情況 | 之前 | 之後 |
|------|------|------|
| 正常回應 (2秒) | ✅ 顯示回應 | ✅ 顯示回應 (更快) |
| API 限流 (等待中) | ⏳ 一直卡住 | ⏳ 30秒後重試，45秒後超時提示 |
| 伺服器缓慢 (50秒) | ⏳ 一直卡住 | ⏳ 30秒超時提示，用戶可重試 |
| 網路中斷 | ⏳ 一直卡住 | ❌ 立即顯示錯誤，用戶知道問題 |

---

## 🚀 部署狀態

- **提交時間:** 已推送到 GitHub
- **部署狀態:** Vercel 正在自動部署
- **預計上線時間:** 2-3 分鐘
- **部署 URL:** https://web-dreamcoreshop.vercel.app/

---

## 🔍 監控 & 調試

### 如何查看完整日誌?

1. **瀏覽器開發者工具 (F12)**
   - 開啟 Console 標籤
   - 所有 `[Chat]` 日誌都會顯示在這裡
   - 查看請求 URL、狀態、回應內容

2. **後端日誌**
   ```bash
   node backend/server.js
   # 會看到類似:
   # [Chat] 發送請求到: http://localhost:3000/api/chat 超時時間: 45秒
   # [ORAPI] 準備發送請求到 google/gemma-3-27b-it:free，超時時間: 30000ms
   # [ORAPI] 成功收到回應，處理中...
   ```

### 如何修改超時時間?

**後端超時** (backend/server.js 中的 sendMessage 呼叫):
```javascript
const response = await sendMessage({ messages, model, timeout: 45000 })
```

**前端超時** (script.js 第 122-126 行):
```javascript
const timeoutPromise = new Promise((_, reject) => {
  setTimeout(() => {
    reject(new Error('...'))
  }, 60000) // 改為 60000 (60 秒)
})
```

---

## 📝 已知限制

1. **Vercel 邊界函數超時限制**: Vercel 預設邊界函數超時 60 秒
   - 若 OpenRouter 響應超過 60 秒，Vercel 會終止請求
   - 解決方案: 升級 Vercel 額度或使用背景工作

2. **瀏覽器標籤頁超時**: 部分瀏覽器有 6 分鐘標籤頁背景超時
   - 用戶若將標籤頁最小化可能被終止
   - 這是瀏覽器級別的限制，無法在代碼中解決

---

## 💬 後續建議

1. **可選:** 新增重試計數顯示 (e.g., 「重試第 2 次」)
2. **可選:** 新增用戶友好的「重試」按鈕
3. **可選:** 整合 Sentry 進行線上錯誤監控
4. **可選:** 新增 WebSocket 替代 Fetch 實現實時通訊

---

**AI 客服助手無回應問題修正完成！🎉**

**預期效果:** 用戶再也不會遇到「一直卡住」的情況，所有超時都會收到清晰的錯誤提示。
